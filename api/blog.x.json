{
  "blog": [
    {
      "filename": "20200515-npm-deploy-package.md",
      "markdown": "```sh\r\nnpm login\r\n```\r\n\r\n```sh\r\nnpm publish .\r\n```\r\n\r\n```sh\r\nnpm unpublish package_name --froce\r\n```\r\n\r\n## 切换镜像\r\n\r\n- https://registry.npm.taobao.org/\r\n- http://registry.npmjs.org/",
      "id": "4KXIHV0_x",
      "meta": {
        "title": "NPM发布包",
        "author": "murph",
        "hidden": true
      },
      "summary": "```sh\r\nnpm login\r\n```\r\n\r\n```sh\r\nnpm publish .\r\n```\r\n\r\n```sh\r\nnpm unpublish package_name --froce\r\n```\r\n\r\n## 切换镜像\r\n\r\n- https://registry.npm.taobao.org/\r\n- http://registry.npmjs.org/"
    },
    {
      "filename": "20200506-win10-shortcuts.md",
      "markdown": "快捷键，指使用某些特定的按键、按键顺序或按键组合，来执行通常使用鼠标执行的操作。对注重人来说，熟悉了某款软件的第一步就是快捷键了。`Windows 10`中内置了大量的快捷键，以提升用户的操作效率。\r\n\r\n<!-- more -->\r\n\r\n### 文字处理\r\n\r\n- 复制/剪切/粘贴： CTRL + C / CTRL + X / CTRL + V\r\n- 文本内容的对齐、缩进： Tab / Shift + Tab\r\n\r\n#### 文字的风格化\r\n\r\n- 加粗： CTRL + B\r\n- 斜体： CTRL + I\r\n- 下划线： CTRL + U\r\n\r\n### 窗口操作\r\n\r\n- 关闭Tab、窗口： CTRL + W / ALT + F4\r\n- 窗口切换： ALT + Tab / Windows + Tab\r\n\r\n### 系统控制\r\n\r\n> Windows + X、 U、 U\r\n\r\n```cmd\r\n# 关机脚本\r\n%windir%\\System32\\SlideToShutDown.exe\r\n```",
      "id": "aXVfqw2ODd",
      "meta": {
        "title": "Windows10常用快捷操作",
        "author": "murph",
        "hidden": true
      },
      "summary": "快捷键，指使用某些特定的按键、按键顺序或按键组合，来执行通常使用鼠标执行的操作。对注重人来说，熟悉了某款软件的第一步就是快捷键了。`Windows 10`中内置了大量的快捷键，以提升用户的操作效率。"
    },
    {
      "filename": "20200414-wmp-data-exchange.md",
      "markdown": "微信小程序作为本地化的`HTML5`应用，吸收了大多数现代的`HTML5`前端框架的优势与特点。\n\n<!--more-->\n\n### 向目标页面传输数据\n\n\n### app.globalData\n\n### EventChannel",
      "id": "B21NkJJkHl",
      "meta": {
        "title": "微信小程序跨页面传输数据",
        "author": "murph",
        "hidden": true
      },
      "summary": "微信小程序作为本地化的`HTML5`应用，吸收了大多数现代的`HTML5`前端框架的优势与特点。"
    },
    {
      "filename": "20191205-diff-db-and-dw.md",
      "markdown": "今天和同事做分享，被问及这个问题时禁不住一窒，好像从来没有思考过这个问题，抑或是注入此类的问题。打哈哈的同时，竟然在心里调笑起了曾经的自己：对，“数据库”是“数据仓库”简称。二者之间没有任何区别……呸，是时候自我敲打了！嗯，是的！！！数据库和数据仓库当然是两种不同的东西，“盲人摸象”的话，它们似乎别无二致；但若要深究起来，区别还是显而易见的。\r\n\r\n<!--more-->\r\n\r\n既然说本质区别，一个是为了响应时间，一个是为了吞吐量。\r\n\r\n数据仓库（Data Warehouse）是一个面向主题的（Subject Oriented）、集成的（Integrate）、相对稳定的（Non-Volatile）、反映历史变化（Time Variant）的数据集合，用于支持管理决策。\r\n\r\n1. 面向主题：指数据仓库中的数据是按照一定的主题域进行组织；\r\n1. 集成：指对原有分散的数据库数据经过系统加工, 整理得到的消除源数据中的不一致性；\r\n1. 相对稳定：指一旦某个数据进入数据仓库以后只需要定期的加载、刷新；\r\n1. 反映历史变化：指通过这些信息，对企业的发展历程和未来趋势做出定量分析预测。\r\n\r\n数据仓库建设是一个工程，是一个过程，而不是一种可以购买的产品。企业数据处理方式是以联机事务处理形式信息，并利用信息进行决策；在信息应用过程中管理信息。\r\n\r\n数据仓库的出现，并不是要取代数据库。目前，大部分数据仓库还是用关系数据库管理系统来管理的。数据仓库与数据库的主要区别在于：\r\n\r\n1. 数据库是面向事务的设计，数据仓库是面向主题设计的；\r\n1. 数据库一般存储在线交易数据，数据仓库存储的一般是历史数据；\r\n1. 数据库设计是尽量避免冗余，数据仓库在设计是有意引入冗余；\r\n1. 数据库是为捕获数据而设计，数据仓库是为分析数据而设计。\r\n\r\n简而言之，数据库是面向事务的设计，数据仓库是面向主题设计的。\r\n\r\n数据库一般存储在线交易数据，数据仓库存储的一般是历史数据。\r\n\r\n数据库设计是尽量避免冗余，一般采用符合范式的规则来设计，数据仓库在设计是有意引入冗余，采用反范式的方式来设计。\r\n\r\n数据库是为捕获数据而设计，数据仓库是为分析数据而设计，它的两个基本的元素是维表和事实表。",
      "id": "34otaFWaoQ",
      "meta": {
        "title": "数据仓库和数据库的区别",
        "author": "murph"
      },
      "summary": "今天和同事做分享，被问及这个问题时禁不住一窒，好像从来没有思考过这个问题，抑或是注入此类的问题。打哈哈的同时，竟然在心里调笑起了曾经的自己：对，“数据库”是“数据仓库”简称。二者之间没有任何区别……呸，是时候自我敲打了！嗯，是的！！！数据库和数据仓库当然是两种不同的东西，“盲人摸象”的话，它们似乎别无二致；但若要深究起来，区别还是显而易见的。"
    },
    {
      "filename": "20190416-java-thread-pool.md",
      "markdown": "在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程：\r\n\r\n<!--more-->\r\n\r\n1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗；\r\n2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行；\r\n3. 提高线程的可管理性。",
      "id": "7zGZhmw_X6",
      "meta": {
        "title": "Java中的线程池",
        "author": "murph",
        "hidden": true
      },
      "summary": "在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程："
    },
    {
      "filename": "20190402-java-concurrent.md",
      "markdown": "在Java中有两类线程：用户线程 (User Thread)、守护线程 (Daemon Thread)。 \r\n\r\n<!--more-->\r\n\r\n守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。",
      "id": "Yj_02zR_jg",
      "meta": {
        "title": "Java中的多线程",
        "author": "murph",
        "hidden": true
      },
      "summary": "在Java中有两类线程：用户线程 (User Thread)、守护线程 (Daemon Thread)。"
    },
    {
      "filename": "20180917-before-coding.md",
      "markdown": "我们每个都有自己信奉的哲学，做事情会有自己的范式。写代码之前你会做些什么呢？会不会和我一样，不事先打开谷歌都不知道怎么开始。这当然是句玩笑。相信着手编码之前，大家都会有自己考量。你会思考些什么呢？\r\n\r\n<!--more-->\r\n\r\n### 参考文章\r\n\r\n- [阮一峰 - 如何降低软件的复杂性？](http://www.ruanyifeng.com/blog/2018/09/complexity.html)",
      "id": "C_4b0eL_uD",
      "meta": {
        "title": "开始写代码之前，我们要思考什么？",
        "author": "murph",
        "hidden": true
      },
      "summary": "我们每个都有自己信奉的哲学，做事情会有自己的范式。写代码之前你会做些什么呢？会不会和我一样，不事先打开谷歌都不知道怎么开始。这当然是句玩笑。相信着手编码之前，大家都会有自己考量。你会思考些什么呢？"
    },
    {
      "filename": "20180721-what-is-fail-fast.md",
      "markdown": "[Java，你告诉我 fail-fast 是什么鬼？](https://mp.weixin.qq.com/s/P_advkTtYdfCnK3ovcacBg)",
      "id": "KSPNLc0f9g",
      "meta": {
        "title": "fail-fast是什么鬼？",
        "author": "murph",
        "hidden": true
      },
      "summary": "[Java，你告诉我 fail-fast 是什么鬼？](https://mp.weixin.qq.com/s/P_advkTtYdfCnK3ovcacBg)"
    },
    {
      "filename": "20180713-linux-philosophy.md",
      "markdown": "我们只有对一件事有了深刻的认识，并且认同之后，才有可能去花时间学好。所以首先我认为要深刻认识到`Linux`背后的设计哲学是什么。\r\n\r\n<!-- more -->\r\n\r\n关于 Linux 的设计哲学很多地方都有介绍，我这里也特意没有进行翻译，希望大家对表述中关键的英文单词也建立起认知：\r\n\r\nEverything is a process; if it’s not a process, it’s a file\r\n任何事都是一个进程，或者说一个线程，是一个执行体；如果它不是一个线程，那么它就是一个文件。\r\n\r\n大家不要认为这句话理所当然，其实很多操作系统都没有这样一个概念，但是在 Linux 的世界，大量的东西是以进程的概念存在的。如果你认为它不是一个可以运行的东西，那它极大可能就是个文件。你会发现很多新的技术都是在这样的设计思想之上，比如说容器。\r\n\r\n这种思想的好处是什么呢？我们说解决计算机的问题有一个重要的技巧，就是当你能够把各种复杂的事情都看成是一码事儿，能够从统一的视角去概括它，并且面对它、处理它，那解决起来就会容易很多。因为当计算机面对复杂的现实世界，它能做的就是一层一层的抽象，最后抽出一个非常简单且统一的视角，可以直接地去处理。这是大家在写代码的时候可以去思考的。当你发现你做出的设计能够把两、三个不一样的东西，从一个更高的视角进行统一，这时的你就会比很多人了不起。\r\n\r\nOne tool to do one task\r\n一个工具解决一个问题。它的理念是说要把东西做好、做到极致，就要去做专。如果你做的不能比别人更好，你就不要去做，而是要去想如何通过一种方式让用户可以在你的应用上调用自己喜欢的东西，这就是 One tool to do one task。对我们在做程序的时候也有很多帮助，比如是不是能把现在的应用做得非常内聚，而不是去做更多的东西。\r\n\r\nThree standards I/O channel\r\n每个进程都有三个标准的 I/O：标准输入、标准输出、标准错误，好处是你就会清楚地知道任何终端进程默认都有这三个数据交流的端口，可以自由的进行拼装或者 I/O 重定向，进行功能组合，这其实也就是第四个哲学所说的——\r\n\r\nCombine tools seamlessly\r\n把工具无缝地拼接起来。\r\n\r\nPlain text preferred\r\n这一点也是我非常喜欢的，就是能用 Text 一定要用 Text。Text 是一种人可以读，机器也可以处理的内容，可以解决好多问题。我们一般说 Plain Text 是指英文。比如说大家写注释要用英文写，它带来的好处是，我们可以通过脚本自动化分析各种 Comment，谁的 Comment 写得多，谁的单词拼错了，谁的 Comment 中包含非常重要的信息，需要重点去跟踪等等。\r\n\r\nCLI, not GUI\r\n提倡用命令行，不要用图形化界面。因为命令行可以非常高效进行人机对话，图形化界面对程序员来说是非常低效的。如果做一次更改，我们更希望通过敲键盘的方式来快速告诉计算机应该做什么。\r\n\r\nProvide the mechanism, not the policy\r\n这点我建议大家背下来，就是如果你做一个好的大型框架，应该去提供机制，而不是提供策略。也就是要提供创造更多可能性的能力，不要把需要适应到特殊场景下的定制化的内容写死在代码里。所有的软件在这种设计上这点是非常相通的，好的软件一定是为大家提供更多的灵活性和适用场景。\r\n\r\n参考文章\r\n\r\n[每个程序员都可以「懂」一点 Linux](https://my.oschina.net/u/4084220/blog/3088972?p=2)",
      "id": "zNUJKdOj2B",
      "meta": {
        "title": "Linux设计哲学",
        "author": "murph",
        "hidden": true
      },
      "summary": "我们只有对一件事有了深刻的认识，并且认同之后，才有可能去花时间学好。所以首先我认为要深刻认识到`Linux`背后的设计哲学是什么。"
    },
    {
      "filename": "20170603-spring-annotation.md",
      "markdown": "`Spring`从`2.5`版本开始引入注解来配置依赖注入，将广大`Java`开发人员从冗杂`XML`配置文件中解放出来。`Spring`也由此一举封神，似乎成为了`Java EE`开发圈子的事实标准。`Java`生态下的各类框架也是积极跟进注解配置，`Spring`家族的后续更是一发不可收拾，不断的翻新注解的玩法。近来`Spring Boot`更是登封造极，看到官方文档中需要翻页的注解列表时，不禁有些发怵。在这里整理下`Spring`家族个框架中的常用注解，简单归纳，便于记忆。\r\n\r\n<!--- more --->\r\n\r\n1. 声明bean的注解\r\n\r\n- @Component 组件，没有明确的角色\r\n\r\n- @Service 在业务逻辑层使用（service层）\r\n\r\n- @Repository 在数据访问层使用（dao层）\r\n\r\n- @Controller 在展现层使用，控制器的声明（C）\r\n\r\n2. 注入bean的注解\r\n\r\n- @Autowired：由Spring提供\r\n\r\n- @Inject：由JSR-330提供\r\n\r\n- @Resource：由JSR-250提供\r\n\r\n都可以注解在set方法和属性上，推荐注解在属性上（一目了然，少写代码）。\r\n\r\n3. java配置类相关注解\r\n\r\n- @Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）\r\n\r\n- @Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）\r\n\r\n- @Configuration 声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean（类上）\r\n\r\n- @ComponentScan 用于对Component进行扫描，相当于xml中的（类上）\r\n\r\n- @WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解\r\n\r\n4. 切面（AOP）相关注解\r\n\r\nSpring支持AspectJ的注解式切面编程。\r\n\r\n- @Aspect 声明一个切面（类上）\r\n\r\n使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。\r\n\r\n- @After 在方法执行之后执行（方法上）\r\n\r\n- @Before 在方法执行之前执行（方法上）\r\n\r\n- @Around 在方法执行之前与之后执行（方法上）\r\n\r\n- @PointCut 声明切点\r\n\r\n在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）\r\n\r\n5. @Bean的属性支持\r\n\r\n- @Scope 设置Spring容器如何新建Bean实例（方法上，得有@Bean）\r\n\r\n其设置类型包括：\r\n\r\n- Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）,\r\n\r\n- Protetype （每次调用新建一个bean）,\r\n\r\n- Request （web项目中，给每个http request新建一个bean）,\r\n\r\n- Session （web项目中，给每个http session新建一个bean）,\r\n\r\n- GlobalSession（给每一个 global http session新建一个Bean实例）\r\n\r\n- @StepScope 在Spring Batch中还有涉及\r\n\r\n- @PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod\r\n\r\n- @PreDestory 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod\r\n\r\n6. @Value注解\r\n\r\n- @Value 为属性注入值（属性上）\r\n\r\n支持如下方式的注入：\r\n\r\n注入普通字符\r\n\r\n```\r\n\t@Value(\"Michael Jackson\")\r\n\tString name;\r\n```\r\n\r\n注入操作系统属性\r\n\r\n```\r\n\t@Value(\"#{systemProperties['os.name']}\")\r\n\tString osName;\r\n```\r\n\r\n注入表达式结果\r\n\r\n```\r\n\t@Value(\"#{ T(java.lang.Math).random() * 100 }\")\r\n\tString randomNumber;\r\n```\r\n\r\n注入其它bean属性\r\n\r\n```\r\n\t@Value(\"#{domeClass.name}\")\r\n\tString name;\r\n```\r\n\r\n注入文件资源\r\n\r\n```\r\n\t@Value(\"classpath:com/hgs/hello/test.txt\")\r\n\tString Resource file;\r\n```\r\n\r\n注入网站资源\r\n\r\n```\r\n\t@Value(\"http://www.cznovel.com\")\r\n\tResource url;\r\n```\r\n\r\n注入配置文件\r\n\r\n```\r\n\t@Value(\"${book.name}\")\r\n\tString bookName;\r\n```\r\n\r\n注入配置使用方法：\r\n\r\n1. 编写配置文件（test.properties）\r\n```\r\n\tbook.name=《三体》\r\n```\r\n\r\n2. @PropertySource 加载配置文件(类上)\r\n\r\n```\r\n\t@PropertySource(\"classpath:com/hgs/hello/test/test.propertie\")\r\n```\r\n\r\n3. 还需配置一个PropertySourcesPlaceholderConfigurer的bean。\r\n\r\n7. 环境切换\r\n\r\n- @Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）\r\n\r\n- @Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）\r\n\r\n8.异步相关\r\n\r\n- @EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上）\r\n\r\n- @Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务）\r\n\r\n9.定时任务相关\r\n\r\n- @EnableScheduling 在配置类上使用，开启计划任务的支持（类上）\r\n\r\n- @Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）\r\n\r\n10. `@Enable`注解说明\r\n\r\n这些注解主要用来开启对xxx的支持。\r\n\r\n\r\n- @EnableAspectJAutoProxy 开启对AspectJ自动代理的支持\r\n\r\n- @EnableAsync 开启异步方法的支持\r\n\r\n- @EnableScheduling 开启计划任务的支持\r\n\r\n- @EnableWebMvc 开启Web MVC的配置支持\r\n\r\n- @EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持\r\n\r\n- @EnableJpaRepositories 开启对SpringData JPA Repository的支持\r\n\r\n- @EnableTransactionManagement 开启注解式事务的支持\r\n\r\n- @EnableTransactionManagement 开启注解式事务的支持\r\n\r\n- @EnableCaching 开启注解式的缓存支持\r\n\r\n11.测试相关注解\r\n\r\n- @RunWith 运行器，Spring中通常用于对JUnit的支持\r\n\r\n- @RunWith(SpringJUnit4ClassRunner.class)\r\n\r\n- @ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类\r\n\r\n- @ContextConfiguration(classes={TestConfig.class})\r\n\r\nSpringMVC部分\r\n\r\n- @EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。\r\n\r\n- @Controller 声明该类为SpringMVC中的Controller\r\n\r\n- @RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上）\r\n\r\n- @ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）\r\n\r\n- @RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）\r\n\r\n- @PathVariable 用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。\r\n\r\n- @RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。\r\n\r\n- @ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上，\r\n这对所有注解了 @RequestMapping的控制器内的方法有效。\r\n\r\n- @ExceptionHandler 用于全局处理控制器里的异常\r\n\r\n- @InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。\r\n\r\n- @ModelAttribute \r\n\r\n本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。",
      "id": "x7v79F8QC-",
      "meta": {
        "title": "Spring常用注解",
        "author": "murph",
        "tags": [
          "Java",
          "Spring"
        ],
        "hidden": true
      },
      "summary": "`Spring`从`2.5`版本开始引入注解来配置依赖注入，将广大`Java`开发人员从冗杂`XML`配置文件中解放出来。`Spring`也由此一举封神，似乎成为了`Java EE`开发圈子的事实标准。`Java`生态下的各类框架也是积极跟进注解配置，`Spring`家族的后续更是一发不可收拾，不断的翻新注解的玩法。近来`Spring Boot`更是登封造极，看到官方文档中需要翻页的注解列表时，不禁有些发怵。在这里整理下`Spring`家族个框架中的常用注解，简单归纳，便于记忆。"
    },
    {
      "filename": "20161102-awk-learning-notes.md",
      "markdown": "`AWK`是一个强大的文本分析工具，`Linux`及`Unix`环境中现有的功能最强大的数据处理引擎之一。`AWK`在很多方面类似于`Unix shell`编程语言，尽管`AWK`具有完全属于其本身的语法。它将文件作为记录序列处理。在一般情况下，文件内容的每行都是一个记录。`AWK`一次可以读取一个输入行。对每个输入行，`AWK`解释器会判断它是否符合程序中出现的各个模式，并执行符合的模式所对应的动作。\r\n\r\n<!-- more -->\r\n\r\nAWK程序是由一系列模式/动作对组成的，写做：\r\n\r\n```sh\r\npattern { action }\r\n```\r\n\r\n其中pattern表示AWK在数据中查找的内容，而action是在找到匹配内容时所执行的一系列命令。\r\n\r\n输入行被分成了一些记录：记录默认由换行符分割，因此输入会按照行进行分割。程序使用给定的条件一个个的测试每条记录，并执行测试通过的条件所对应的action。pattern和action都可以省略不写。无pattern默认匹配全部的记录；而无action则是打印原始记录。\r\n\r\n将文件内的每一行以空格分隔，打印每一行的第五列：\r\n\r\n```sh\r\nawk '{print $5}' {{filename}}\r\n```\r\n\r\n通过正则表达式匹配文件内的每一行，然后将行内容以空格分隔，打印每一行的第二列：\r\n\r\n```sh\r\nawk '/{{regexp}}/ {print $2}' {{filename}}\r\nawk '$1 ~ /{{regexp}}/ {print $2}' {{filename}}\r\n```\r\n\r\n指定分隔符，输出每一行的列的数量\r\n\r\n```sh\r\nawk -F ',' '{print $NF}' {{filename}}\r\n```\r\n\r\n### 语句定义\r\n\r\n可以快速的用单引号’ ’，把所有语句写成一行；\r\n也可以用-f 指定文件，文件里可以任意换行，增加可读性和重用性；\r\n所有执行语句用{}括起来，{}的外面是一些高级的东西比如过滤条件；\r\n另外如果打印整列，{print} 可省略不写；\r\n\r\n#### 内置常量\r\n\r\n|  常量   | 释义  | 备注 |\r\n| :----: | :----: | :----: |\r\n| NR  | 行号 | Number of row |\r\n| NF  | 列号 | Number of field |\r\n\r\n### 列引用\r\n\r\n$0代表整行所有数据，$1代表第一列(终于不是程序员数数从0开始了)；\r\nNF是个代表总列数的系统变量，所以$NF代表最后一列，还支持$(NF-1)来表示倒数第二列；\r\n还支持列之间的运算，如$NF-$(NF-1)是最后两列的值相减；\r\n只写一个print 是 print $0的简写，打印整行所有数据；\r\n\r\n### 参考资料\r\n\r\n- [Wikipedia - AWK](https://zh.wikipedia.org/wiki/AWK)",
      "id": "Qmipv72xm4",
      "meta": {
        "title": "AWK学习笔记",
        "author": "murph"
      },
      "summary": "`AWK`是一个强大的文本分析工具，`Linux`及`Unix`环境中现有的功能最强大的数据处理引擎之一。`AWK`在很多方面类似于`Unix shell`编程语言，尽管`AWK`具有完全属于其本身的语法。它将文件作为记录序列处理。在一般情况下，文件内容的每行都是一个记录。`AWK`一次可以读取一个输入行。对每个输入行，`AWK`解释器会判断它是否符合程序中出现的各个模式，并执行符合的模式所对应的动作。"
    }
  ]
}